[toc]

### 并发编程

#### 1. 内存可见性

> (Java Memory Model)  JMM 模型中内存和共享变量存在约束
>
> - 任何线程对共享变量的**所有操作**必须在自己的工作内存中完成，不能直接从主存中读写
> - 线程与线程的工作内存是相互独立的，不能够直接访问，当有需要时，可以通过主存来间接访问

内存可见性是指当某线程修改了共享变量的值的时候，其他线程会马上看到被修改的值。

 ##### 导致共享变量在线程间不可见的原因

- 线程的交叉执行；
- 重排序结合线程的交叉执行；
- 共享变量更新后的值没有在工作内存与主内存及时更新。

##### 			实现内存可见的方法

- volatile 修饰共享变量

- synchronized 给被访问的对象加锁

##### volatile 对比 synchronized

- volatile: 相对于 synchronized 来说，它是比较轻量级的，当有多个线程进行操作共享数据时，可以保证内存中变量可见性，**不能保证代码的原子性，但是可以禁止指令的重排序优化；**

  >  实现内存可见：
  >     深入的说：通过加入内存屏障和禁止重排序优化实现。对其变量执行写操作时，会在写操作后加入一条store屏障指令；对其进行读操作时，会在读操作前加入一条load屏障指令。
  >     通俗的说：volatile变量在每次被线程访问时，都强迫从主线程中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存中，这样任何时刻，不同的线程总能看到该变量最新的值。 

- synchronized: 它是一种互斥锁的做法，当线程访问某个变量之前先对其加锁，其他后来的线程都只能等待锁被释放，一直在阻塞着。**它能够保证内存的可见性和代码的原子性。**

  >  JVM对线程锁的两条规定：
  >
  > - 线程解锁前，必须把共享变量的最新值刷新到主内存中；
  > - 线程枷锁前，将清空工作内存中的共享变量的值，从而使用共享变量时需要从主内存中重新读取新的值。（枷锁与解锁需要是同一把锁）。
  > - 线程解锁前对共享线程变量的修改在下次枷锁时对其他线程可见。 

#### 2. 原子性和 CAS 算法

- 原子性：即一个操作或多个操作在执行的过程中，要么全部执行完成，要么都不执行，不存在执行一半的情况。

- 在 Java 中，对基本数据类型变量的读取和赋值都是原子操作。

  >  在多线程并发操作共享变量时会带来线程安全问题。

##### 实现原子性的方法

1. synchronized 关键字

   > 使用同步代码块对对象加锁操作
   >
   > 1、获得互斥锁；
   > 2、清空工作内存；
   > 3、从主内存拷贝变量的最新的值到工作内存；
   > 4、执行代码；
   > 5、将更改后的共享变量的值刷新到主内存；
   > 6、释放互斥锁。 
2. ReentrantLock 锁  (java.util.concurrent.locks 包下) 

   > 在操作共享变量之前调用 lock()，try{ 操作共享变量 } final{ unlock() } 

3. AtomicXX 原子变量 (java.util.concurrent.atomic 包下) 

   > 使用原子变量提供的方法可以轻松实现并发控制。
   >
   >  AtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。 

   