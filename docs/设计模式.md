### 设计模式概述



### 面向对象设计原则



### 简单工厂模式

##### 简单工厂模式的概述及定义

概述：简单工厂模式并不属于 GoF 的23种经典设计模式，但是它的使用频率也很高，并且常常将它作为学习其他工厂模式的基础。由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，因此简单工厂模式又被称为**静态工厂方法模式**（Static Factory Method Pattern）

定义：定义一个工厂类，它可以根据**参数**的不同返回不同类的示例，被创建的实例通常都具有共同的父类。

##### 简单工厂模式的结构

简单工厂模式的结构比较简单，其核心是工厂类的设计，它包含以下3个角色：

- **Factory（工厂角色）**：简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑，提供静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。
- **Product（抽象产品角色）**：它是工厂类创建的所有对象的父类，封装了各种产品对象的共有方法
- **ConcreteProduct（具体产品角色）**：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它需要继承抽象产品角色，需要实现在抽象产品中声明的抽象方法。

##### 简单工厂模式的实现

实现情景：开发一套图标库，该图标库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart）等。

- 抽象产品接口

```java
/**
 * 抽象图标接口，充当抽象产品类
 */
public interface Chart {
    void display();
}
```

- 具体产品类

```java
/**
 * 柱状图类，充当具体产品类
 */
public class HistogramChart implements Chart {
    public HistogramChart() {
        System.out.println("创建柱状图");
    }

    @Override
    public void display() {
        System.out.println("显示柱状图");
    }
}

/**
 * 饼状图类，充当具体产品类
 */
public class PieChart implements Chart {
    public PieChart() {
        System.out.println("创建饼状图");
    }

    @Override
    public void display() {
        System.out.println("显示饼状图");
    }
}

/**
 * 折线图类，充当具体产品类
 */
public class LineChart implements Chart {
    public LineChart() {
        System.out.println("创建折线图");
    }

    @Override
    public void display() {
        System.out.println("显示折线图");
    }
}
```

- 工厂类

```java
/**
 * 图表工厂类，充当工厂类
 */
public class ChartFactory {

    //静态工厂方法
    public static Chart getChart(String type){
        Chart chart = null;
        if ("histogram".equalsIgnoreCase(type)) {
            chart = new HistogramChart();
            System.out.println("初始化设置柱状图！");
        } else if ("pie".equalsIgnoreCase(type)) {
            chart = new PieChart();
            System.out.println("初始化设置饼状图！");
        }else if ("line".equalsIgnoreCase(type)) {
            chart = new LineChart();
            System.out.println("初始化设置折线图！");
        }
        return chart;
    }
}
```

- 测试客户端

```java
/**
 * 客户端测试类
 */
public class ChartClient {
    public static void main(String[] args) {
        Chart chart = null;
        chart = ChartFactory.getChart("line");
        chart.display();
    }
}
```

注意：本实例在创建具体 Chart 对象时必须通过修改客户端代码中的静态工厂方法的参数来更换具体产品对象，客户端需要重新编译，这对于客户端而言违反了开闭原则，可以通过引入 xml 配置文件来解决，在需要更换具体图表对象时，只需要修改 xml 配置文件，不需要更改源代码，复合开闭原则。

##### 简单工厂模式的优缺点

优点：

- 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个具体产品对象，客户端不需要直接创建这些对象，而仅仅“消费”产品，实现了对象的创建和使用分离。
- 客户端不需要知道所创建的具体产品类的类名，只需要知道对应的参数即可。
- 通过引入配置文件，可以在不修改客户端源代码的情况下更换和增加新的具体产品类

缺点：

- 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都会受到影响。
- **系统拓展困难，一旦添加新产品就不得不修改工厂类逻辑**，在产品类型较多时有可能造成工厂逻辑过于复杂，不利于系统的拓展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

##### 简单工厂模式的适应环境

- 工厂类负责创建的对象较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象并不需要关心。

### 工厂方法模式



### 抽象工厂模式



### 建造者模式



### 单例模式



### 原型模式